// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package graph represents the imported interface "wasi:nn/graph@0.2.0-rc-2024-08-19".
//
// A `graph` is a loaded instance of a specific ML model (e.g., MobileNet) for a specific
// ML
// framework (e.g., TensorFlow):
package graph

import (
	"github.com/bytecodealliance/wasm-tools-go/cm"
	"github.com/hayride-dev/bindgen/gen/go/wasi/nn/errors"
	"github.com/hayride-dev/bindgen/gen/go/wasi/nn/inference"
)

// Graph represents the imported resource "wasi:nn/graph@0.2.0-rc-2024-08-19#graph".
//
// An execution graph for performing inference (i.e., a model).
//
//	resource graph
type Graph cm.Resource

// ResourceDrop represents the imported resource-drop for resource "graph".
//
// Drops a resource handle.
//
//go:nosplit
func (self Graph) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_GraphResourceDrop((uint32)(self0))
	return
}

//go:wasmimport wasi:nn/graph@0.2.0-rc-2024-08-19 [resource-drop]graph
//go:noescape
func wasmimport_GraphResourceDrop(self0 uint32)

// InitExecutionContext represents the imported method "init-execution-context".
//
//	init-execution-context: func() -> result<graph-execution-context, error>
//
//go:nosplit
func (self Graph) InitExecutionContext() (result cm.Result[inference.GraphExecutionContext, inference.GraphExecutionContext, errors.Error]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_GraphInitExecutionContext((uint32)(self0), &result)
	return
}

//go:wasmimport wasi:nn/graph@0.2.0-rc-2024-08-19 [method]graph.init-execution-context
//go:noescape
func wasmimport_GraphInitExecutionContext(self0 uint32, result *cm.Result[inference.GraphExecutionContext, inference.GraphExecutionContext, errors.Error])

// GraphEncoding represents the enum "wasi:nn/graph@0.2.0-rc-2024-08-19#graph-encoding".
//
// Describes the encoding of the graph. This allows the API to be implemented by various
// backends that encode (i.e., serialize) their graph IR with different formats.
//
//	enum graph-encoding {
//		openvino,
//		onnx,
//		tensorflow,
//		pytorch,
//		tensorflowlite,
//		ggml,
//		autodetect
//	}
type GraphEncoding uint8

const (
	GraphEncodingOpenvino GraphEncoding = iota
	GraphEncodingOnnx
	GraphEncodingTensorflow
	GraphEncodingPytorch
	GraphEncodingTensorflowlite
	GraphEncodingGgml
	GraphEncodingAutodetect
)

var stringsGraphEncoding = [7]string{
	"openvino",
	"onnx",
	"tensorflow",
	"pytorch",
	"tensorflowlite",
	"ggml",
	"autodetect",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e GraphEncoding) String() string {
	return stringsGraphEncoding[e]
}

// ExecutionTarget represents the enum "wasi:nn/graph@0.2.0-rc-2024-08-19#execution-target".
//
// Define where the graph should be executed.
//
//	enum execution-target {
//		cpu,
//		gpu,
//		tpu
//	}
type ExecutionTarget uint8

const (
	ExecutionTargetCPU ExecutionTarget = iota
	ExecutionTargetGpu
	ExecutionTargetTpu
)

var stringsExecutionTarget = [3]string{
	"cpu",
	"gpu",
	"tpu",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ExecutionTarget) String() string {
	return stringsExecutionTarget[e]
}

// GraphBuilder represents the list "wasi:nn/graph@0.2.0-rc-2024-08-19#graph-builder".
//
// The graph initialization data.
//
// This gets bundled up into an array of buffers because implementing backends may
// encode their
// graph IR in parts (e.g., OpenVINO stores its IR and weights separately).
//
//	type graph-builder = list<u8>
type GraphBuilder cm.List[uint8]

// Load represents the imported function "load".
//
// Load a `graph` from an opaque sequence of bytes to use for inference.
//
//	load: func(builder: list<graph-builder>, encoding: graph-encoding, target: execution-target)
//	-> result<graph, error>
//
//go:nosplit
func Load(builder cm.List[GraphBuilder], encoding GraphEncoding, target ExecutionTarget) (result cm.Result[Graph, Graph, errors.Error]) {
	builder0, builder1 := cm.LowerList(builder)
	encoding0 := (uint32)(encoding)
	target0 := (uint32)(target)
	wasmimport_Load((*GraphBuilder)(builder0), (uint32)(builder1), (uint32)(encoding0), (uint32)(target0), &result)
	return
}

//go:wasmimport wasi:nn/graph@0.2.0-rc-2024-08-19 load
//go:noescape
func wasmimport_Load(builder0 *GraphBuilder, builder1 uint32, encoding0 uint32, target0 uint32, result *cm.Result[Graph, Graph, errors.Error])

// LoadByName represents the imported function "load-by-name".
//
// Load a `graph` by name.
//
// How the host expects the names to be passed and how it stores the graphs for retrieval
// via
// this function is **implementation-specific**. This allows hosts to choose name
// schemes that
// range from simple to complex (e.g., URLs?) and caching mechanisms of various kinds.
//
//	load-by-name: func(name: string) -> result<graph, error>
//
//go:nosplit
func LoadByName(name string) (result cm.Result[Graph, Graph, errors.Error]) {
	name0, name1 := cm.LowerString(name)
	wasmimport_LoadByName((*uint8)(name0), (uint32)(name1), &result)
	return
}

//go:wasmimport wasi:nn/graph@0.2.0-rc-2024-08-19 load-by-name
//go:noescape
func wasmimport_LoadByName(name0 *uint8, name1 uint32, result *cm.Result[Graph, Graph, errors.Error])
